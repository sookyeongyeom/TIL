# String 클래스의 구현

## 구현 사항

1. 문자열을 인자로 전달받는 생성자의 정의 → String str1="I..." ≡ String str1("I...")

2. 생성자, 소멸자, 복사생성자, 대입연산자의 정의 → 문자열의 길이가 일정치 않으므로 동적할당을 해야하기 때문임

3. 결합된 문자열로 초기화된 객체를 반환하는 + 연산자 오버로딩

4. 문자열을 덧붙이는 += 연산자의 오버로딩

5. 내용비교를 진행하는 == 연산자의 오버로딩

6. 콘솔입출력이 가능하도록 <<, >> 연산자의 오버로딩

## String 클래스

```cpp
class String
{
    char* str;
public:
    String()
    {
        str = NULL;
    }
    String(const char* str)         // 생성자
    {
        this->str = new char[strlen(str) + 1];
        strcpy(this->str, str);
    }
    String(const String& ref)       // 복사생성자
    {
        str = new char[strlen(ref.str) + 1];
        strcpy(str, ref.str);
    }
    String& operator=(const String& ref)        // 대입연산자
    {
        delete[]str;
        str = new char[strlen(ref.str) + 1];
        strcpy(str, ref.str);
        return *this;
    }
    ~String()       // 소멸자
    {
        if (str != NULL)
            delete[]str;
    }

    String operator+(const String& ref)
    {
        char* newStr = new char[strlen(str) + strlen(ref.str) + 1];
        strcpy(newStr, str);        // NULL 상태에서는 strcpy부터 해주어야 함
        strcat(newStr, ref.str);
        String temp(newStr);
        delete[]newStr;
        return temp;
    }

    String& operator+=(const String& ref)
    {
        char* newStr = new char[strlen(str) + strlen(ref.str) + 1];
        strcpy(newStr, str);
        strcat(newStr, ref.str);
        if (str != NULL)
            delete[]str;
        str = newStr;
        return *this;
    }

    bool operator==(const String& ref)
    {
        if (!strcmp(str, ref.str))
            return true;
        else
            return false;
    }

    friend ostream& operator<<(ostream&, const String&);
    friend istream& operator>>(istream&, String&);
};

ostream& operator<<(ostream& os, const String& ref)
{
    os << ref.str;
    return os;
}

istream& operator>>(istream& is, String& ref)
{
    char str[100];
    is >> str;
    ref = String(str);
    return is;
}
```
