# 디폴트 대입연산자의 문제점

디폴트 대입연산자의 문제점 = 얕은 복사

디폴트 복사생성자의 문제점 및 해결책과 유사하다.

디폴트 대입연산자는 디폴트 복사생성자와 마찬가지로 멤버 대 멤버를 단순히 복사하므로  
다음의 두가지 문제가 발생하게 된다.

1. 기존의 문자열을 가리키던 문자열의 주소값을 잃게 된다.
2. 얕은 복사로 인해, 객체 소멸과정에서 지워진 문자열을 중복 소멸하는 문제가 발생한다.

디폴트 복사생성자의 문제점과 다른 부분은 1에 있다.  
대입연산의 경우, 이미 생성된 객체의 문자열을 새로운 객체 정보로 덮어씌우는 것이기 때문에   
기존의 문자열이 저장된 메모리에 누수가 발생한다. (주소값을 잃어버려 접근이 불가하다.)  
따라서 깊은 복사를 위해 정의한 대입연산자에서 기존의 문자열을 delete 해주어야 한다.  

따라서 해결책은 다음과 같다.

1. 깊은 복사를 진행하도록 정의
2. 메모리 누수 방지를 위해 깊은 복사에 앞서 메모리 해제의 과정을 거침

```cpp
Person& operator=(const Person& ref)
{
    delete[]name;       // 메모리 누수를 막기 위한 메모리 해제 연산
    name = new char[strlen(ref.name)+1];
    strcpy(name, ref.name);
    age = ref.age;
    return *this;
}
```
