# 일반 오버라이딩 함수와 virtual 오버라이딩 함수의 동작 방식 차이

예제 8-1-1을 풀던 중 맞닥뜨렸던 문제다.  
고민하고 로그찍으면서 나름대로 이해해보았다.  
따라서 내용이 틀릴 수도 있다.  
앞으로 더 공부하다보면 확실히 알게될 날이 있을테다.  
 
## 문제 상황
 
AAA 클래스에 F1과 F2가 있다고 치자.  
F2 내부에서는 F1을 호출하여 그 반환값을 출력하고 있다.  

BBB 클래스는 AAA 클래스를 상속한다.   
BBB 클래스에서는 F1을 오버라이딩한다.  

```cpp
class AAA
{
    F1() { ... }
 // virtual F1() { ... }
    F2() { cout << F1() << endl; }
}

class BBB : public AAA
{
    F1() { ... }
}
```

BBB 객체가 있다.  
BBB 객체에서 F2을 호출했을 때  
F1이 일반 함수인 경우와 가상 함수인 경우에 각각 그 출력값이 달랐다.  

F1이 일반 함수인 경우,  
BBB 객체를 가리키는 포인터에 상관없이  
출력값은 AAA::F1이 나왔다.

반면 F1이 가상 함수인 경우,  
역시 BBB 객체를 가리키는 포인터에 상관없이  
출력값은 BBB::F1이 나왔다.

## 일반 오버라이딩 함수

기초클래스의 함수 내부에서 호출된 일반 함수는 유도클래스에서 오버라이딩되었어도 기초클래스 기준으로 실행된다.  

클래스 일반 함수의 동작 방식은 다음과 같다.  
함수 자체는 어딘가의 메모리 공간에 올라가고 클래스 내부에는 해당 공간을 참조하기 위한 주소값(AAA::F2)이 남는다.  

따라서 F2 호출 시 F2가 저장되어 있는 메모리 공간을 참조하고,  
이후 F1의 호출을 위해 이번엔 F1이 저장되어 있는 메모리 공간을 참조하게 된다.  

BBB가 상속받은 F2 함수는 애초에 AAA의 함수고, 정확히는 AAA::F2라고 봐야 맞다.  
(BBB가 F2를 오버라이딩하게 되면 BBB에는 BBB::F2의 참조값이 생긴다.)  
AAA::F2 내부에서 호출되는 F1은 사실상 AAA::F1이므로 기초클래스의 F1이 호출되는 것이다.  

## virtual 오버라이딩 함수

기초클래스의 함수 내부에서 호출된 virtual 함수는 유도클래스에서 오버라이딩되었다면 유도클래스 기준으로 실행된다.  

가상 함수의 동작 방식은 일반 함수와는 조금 다르다.  
가상 함수를 하나 이상 포함하는 AAA 클래스가 생성되면 객체 생성과는 무관하게 AAA의 Virtual Table이 생성된다.  

|함수|주소|
|---|---|
|AAA::F1|0x12|
|AAA::F2|0x35|

이렇게 생겼다고 보면 된다.  

Virtual Table은 실제 호출되어야 할 함수의 위치정보를 담고 있는 테이블로,  
해당 클래스가 하나 이상의 가상 함수를 갖고 있다면 무조건 생성되며 가상 함수뿐만 아니라 일반 함수도 이 테이블을 참조하여 호출하게 된다.  
(C++이 C보다 느린 이유이기도 하다.)

다음으로 BBB 클래스가 생성되면 이번에는 BBB의 Virtual Table이 생성된다.  

|함수|주소|
|---|---|
|BBB::F1|0x24|
|AAA::F2|0x35|

F1이 오버라이딩 되었으므로 AAA::F1은 테이블에서 제거되고 BBB::F1이 새로 생긴다.  

객체의 가상 함수가 실행될 때는 가장 먼저 객체 본인이 속한 클래스의 Virtual Table을 참조한다.  
BBB 객체의 F1을 호출하면, 이 테이블을 보고 BBB::F1을 호출한다고 이해하면 된다.  
이러한 원리에 따라 virtual로 선언된 가상 함수는 해당 객체를 기준으로 가장 마지막에 오버라이딩한 함수를 호출하게 되는 것이다.  

따라서 위 상황에서 BBB 객체는 F2 호출을 위해 Virtual Table을 참조하여 AAA::F2를 호출한 후,  
AAA::F2 내부에서 F1을 호출하기 위해 다시 Virtual Table을 참조하여 이번에는 BBB::F1을 참조하게 된다.  
