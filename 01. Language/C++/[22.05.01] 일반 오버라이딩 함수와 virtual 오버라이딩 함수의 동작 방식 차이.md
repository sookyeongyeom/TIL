# 일반 오버라이딩 함수와 virtual 오버라이딩 함수의 동작 방식 차이

예제 8-1-1을 풀던 중 맞닥뜨렸던 문제다.  
고민하고 로그찍으면서 나름대로 이해해보았다.  
따라서 내용이 틀릴 수도 있다.  
앞으로 더 공부하다보면 확실히 알게될 날이 있을테다.  
 
## 문제 상황
 
AAA 클래스에 F1()과 F2()가 있다고 치자.  
F2() 내부에서는 F1()을 호출하여 그 반환값을 출력하고 있다.  

BBB 클래스는 AAA 클래스를 상속한다.   
BBB 클래스에서는 F1()을 오버라이딩한다.  

```cpp
class AAA
{
    F1() { ... }
 // virtual F1() { ... }
    F2() { cout << F1() << endl; }
}

class BBB : public AAA
{
    F1() { ... }
}
```

BBB 객체가 있다.  
BBB 객체에서 F2()을 호출했을 때  
F1()이 일반 함수인 경우와 가상 함수인 경우에 각각 그 출력값이 달랐다.  

F1()이 일반 함수인 경우,  
BBB 객체를 가리키는 포인터에 상관없이  
출력값은 AAA::F1()이 나왔다.

반면 F1()이 가상 함수인 경우,  
역시 BBB 객체를 가리키는 포인터에 상관없이  
출력값은 BBB::F1()이 나왔다.

## 일반 오버라이딩 함수

기초클래스의 함수 내부에서 호출된 함수는 유도클래스에서 오버라이딩되었어도 기초클래스 기준으로 실행된다.  

클래스 일반 함수의 동작 방식은 다음과 같다.  
함수 자체는 어딘가의 메모리 공간에 올라가고 클래스 내부에는 해당 공간을 참조하기 위한 주소값이 남는다.  

따라서 F2() 호출 시 F2()가 저장되어 있는 메모리 공간을 참조하고,  
이후 F1()의 호출을 위해 이번엔 F1()이 저장되어 있는 메모리 공간을 참조하게 된다.  

BBB가 상속받은 F2() 함수는 애초에 AAA의 함수고, 정확히는 AAA::F2()라고 봐야 맞다.  
(BBB가 F2()를 오버라이딩하게 되면 BBB에는 BBB::F2()의 참조값이 생긴다.)  
AAA::F2() 내부에서 호출되는 F1()은 사실상 AAA::F1()이므로 기초클래스의 F1()이 호출되는 것이다.  

## virtual 오버라이딩 함수

기초클래스의 함수 내부에서 호출된 함수가 유도클래스에서 오버라이딩되었다면 유도클래스 기준으로 실행된다.  

가상 함수의 동작 방식은 일반 함수와는 조금 다르다.  
가상 함수를 하나 이상 포함하는 AAA 클래스가 생성되면 객체 생성과는 무관하게 AAA의 Virtual Table이 생성된다.  

|함수|주소|
|---|---|
|AAA::F1()|0x12|
|AAA::F2()|0x35|

이렇게 생겼다고 보면 된다.  

다음으로 BBB 클래스가 생성되면 이번에는 BBB의 Virtual Table이 생성된다.  

|함수|주소|
|---|---|
|BBB::F1()|0x24|
|AAA::F2()|0x35|

F1()이 오버라이딩 되었으므로 AAA::F1()은 테이블에서 제거되고 BBB::F1()이 새로 생긴다.  

객체의 가상 함수가 실행될 때는 가장 먼저 객체 본인이 속한 클래스의 Virtual Table을 참조한다.  
BBB 객체의 F1()이 호출됐다면, 이 테이블을 보고 BBB::F1()을 호출한다고 이해하면 된다.  
이러한 원리에 따라 virtual로 선언된 가상 함수는 해당 객체를 기준으로 가장 마지막에 오버라이딩된 함수를 호출하게 되는 것이다.  

따라서 위 상황에서 BBB 객체는 F2() 호출을 위해 Virtual Table을 참조하여 AAA::F2()를 호출한 후,  
AAA::F2() 내부에서 F1()을 호출하기 위해 다시 Virtual Table을 참조하여 이번에는 BBB::F1()을 참조하게 된다.  
