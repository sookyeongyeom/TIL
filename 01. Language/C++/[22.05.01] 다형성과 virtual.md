# 다형성과 virtual

## 요약

다형성 = Polymorphism = 유도가 기초인척 할 수 있는 것

다형성의 효용은
하나의 기초클래스를 상속받는 여러개의 유도클래스가 기초클래스 포인터 배열에 함께 담겨 관리될 수 있다는 점이다.  
이 때 객체에 따라 실행 형태는 달라져야 진정한 의미가 있는데,  
유도클래스 객체라 할지라도 기초클래스 포인터로 가리키는 이상 기초클래스 멤버함수만을 사용할 수 있다.  
```cpp
Base* bptr = new Derived();     // 컴파일 OK
bptr->DerivedFunc();    // 컴파일 에러
```
C++ 컴파일러는 포인터를 이용한 연산의 가능성 여부를 판단할 때,  
포인터의 자료형을 기준으로 판단하지, 실제 가리키는 객체의 자료형을 기준으로 판단하지 않기 때문이다.

따라서 이런 상황을 해결하기 위한 것이 virtual 키워드다.  
유도클래스에서 오버라이딩할 멤버함수에 virtual 키워드를 붙여주면 해당 함수는 가상함수가 된다.   

가상함수는 호출 시 포인터의 자료형을 기반으로 호출 대상을 결정하지 않고  
포인터 변수가 실제로 가리키는 객체를 참조하여 호출 대상을 결정하므로  
기초클래스의 포인터로 가리킬지라도 유도클래스에서 오버라이딩한 함수가 호출된다.  

## 의식의 흐름대로 정리

문제상황 :  
employee ← permanent ← sales  
└ temp  

이런 상황에서 핸들러는 employee 포인터로 모든 객체를 한 배열에 집어넣고 있음  
getpay(), showSalary() 이게 각 객체마다 다르게 오버라이딩되어있는데  
핸들러에서 각 객체의 getpay(), showsalary()를 호출할 수가 없는 상황임  
왜냐? employee포인터니까 employee 클래스에 정의된 함수만 사용할 수가 잇그든  

이걸 해결하는 방법이 virtual임  
virtual 키워드를 사용하면 포인터가 가리키고 있는 객체 기준으로  
해당 함수를 가장 마지막에 오버라이딩한 함수를 호출하게 됨  
먼소리냐면
```cpp
Third* tptr = new Third();
Second* sptr = tptr;
sptr->SimpleFunc();
```
Second 클래스와 Third 클래스에서 SimpleFunc()을 오버라이딩하고  
Second 포인터로 Third 객체를 가리킨 경우,
1. virtual 선언을 안한 상황이라면
→ Second 클래스의 SimpleFunc()이 호출됨
2. virtual 선언을 한 상황이라면
→ Third 클래스의 SimpleFunc()이 호출됨
