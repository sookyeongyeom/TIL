# 재귀함수 하노이의 탑

```cpp
void HanoiTowerMove(int num, char from, char by, char to)
{
    if (num == 1)
        printf("원반1을 %c에서 %c로 이동\n", from, to);
    else
    {
        HanoiTowerMove(num - 1, from, to, by);      // 3단계 중 1단계 (맨 아래 제외 나머지 원반을 경유지에 이동)
        printf("원반%d을(를) %c에서 %c로 이동\n", num, from, to);        // 3단계 중 2단계 (맨 아래 원반을 최종 목적지로 이동)
        HanoiTowerMove(num - 1, by, from, to);      // 3단계 중 3단계 (경유지에 있는 원반들을 최종 목적지로 이동)
    }
}

int main()
{
    // 막대A의 원반 3개를 막대B를 경유하여 막대C로 옮기기
    HanoiTowerMove(3, 'A', 'B', 'C');
    return 0;
}
```
```
원반1을 A에서 C로 이동
원반2을(를) A에서 B로 이동
원반1을 C에서 B로 이동
원반3을(를) A에서 C로 이동
원반1을 B에서 A로 이동
원반2을(를) B에서 C로 이동
원반1을 A에서 C로 이동
```

### 기억할 것

3개의 원반을 옮겨야하는 문제를 총 3단계로 세분화하여 풀어낸 알고리즘이다.  

1. 맨 아래 제외 나머지 원반을 경유지에 이동
2. 맨 아래 원반을 최종 목적지로 이동
3. 경유지에 옮겨뒀던 원반들을 최종 목적지로 이동

이 알고리즘에서 가장 염두해서 봐야할 것은 탈출 조건인데, 가장 작은 원반을 from에서 to로 옮겨준 후 반환이 시작된다.

로직을 자세히 보면,    
가장 위에 올라와있는 1번 원반을 먼저 옮긴 후, 남은 곳에 2번 원반을 옮기고, 2번 원반위에 1번 원반을 쌓아준다.   
이제 3번 원반을 최종 목적지로 옮긴 후, 이번에는 1번 원반과 2번 원반을 3번 원반위에 쌓아주기 위해 아까와 동일한 로직을 반복한다.   
(3번 원반이 없다고 생각하고 그냥 B에서 시작하여 A를 경유하여 C에 두 개의 원반을 쌓아준다고 생각하는 것이다!)
